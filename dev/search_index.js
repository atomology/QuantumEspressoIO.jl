var documenterSearchIndex = {"docs":
[{"location":"api/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/utils/#Index","page":"Utilities","title":"Index","text":"Pages = [\n    \"utils.md\",\n]","category":"section"},{"location":"api/utils/#Documentation","page":"Utilities","title":"Documentation","text":"","category":"section"},{"location":"api/utils/#QuantumEspressoIO.cart2frac","page":"Utilities","title":"QuantumEspressoIO.cart2frac","text":"Convert Cartesian to fractional coordinates based on lattice vectors.\n\nArguments\n\nlattice: Each element is a lattice vector.\nFor lattice vectors, the unit is usually in angstrom.\nFor reciprocal lattice vectors, the unit is usually in 1/angstrom.\nvec: a vector or a list of vectors in Cartesian coordinates.\n\nExamples\n\nlattice = [[0.0, 1.0, 2.0], [3.0, 0.0, 4.0], [5.0, 6.0, 0.0]];\npositions = [[2.1, 1.9, 1.0], [21.0, 19.0, 10.0]];\nfrac2cart(lattice, cart2frac(lattice, positions[1])) ≈ positions[1]\n# output\ntrue\n\nfrac2cart(lattice, cart2frac(lattice, positions)) ≈ positions\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#QuantumEspressoIO.frac2cart","page":"Utilities","title":"QuantumEspressoIO.frac2cart","text":"Convert fractional to Cartesian coordinates based on lattice vectors.\n\nArguments\n\nlattice: Each element is a lattice vector.\nFor lattice vectors, the unit is usually in angstrom.\nFor reciprocal lattice vectors, the unit is usually in 1/angstrom.\nvec: a vector or a list of vectors in fractional coordinates.\n\nExamples\n\nlattice = [[0.0, 1.0, 2.0], [3.0, 0.0, 4.0], [5.0, 6.0, 0.0]];\npositions = [[0.1, 0.2, 0.3], [1.0, 2.0, 3.0]];\nfrac2cart(lattice, positions[1])\n# output\n3-element Vector{Float64}:\n 2.1\n 1.9\n 1.0\n\nfrac2cart(lattice, positions)\n# output\n2-element Vector{Vector{Float64}}:\n [2.1, 1.9, 1.0]\n [21.0, 19.0, 10.0]\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#QuantumEspressoIO.get_lattice","page":"Utilities","title":"QuantumEspressoIO.get_lattice","text":"Compute real-space lattice vectors from reciprocal-space lattice vectors.\n\nArguments\n\nrecip_lattice: Can be a vector of reciprocal lattice vectors, or a Mat3 matrix.\n\nExamples\n\nrecip_lattice = [[0.0, 1.0, 2.0], [3.0, 0.0, 4.0], [5.0, 6.0, 0.0]];\nget_lattice(recip_lattice)\n# output\n3-element Vector{Vector{Float64}}:\n [-2.6927937030769655, 2.243994752564138, 2.019595277307724]\n [1.3463968515384828, -1.121997376282069, 0.5609986881410345]\n [0.4487989505128276, 0.6731984257692414, -0.3365992128846207]\n\nrecip_lattice = mat3(recip_lattice);\nget_lattice(recip_lattice)\n# output\n3×3 StaticArraysCore.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n -2.69279   1.3464     0.448799\n  2.24399  -1.122      0.673198\n  2.0196    0.560999  -0.336599\n\nget_recip_lattice(get_lattice(recip_lattice)) ≈ recip_lattice\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#QuantumEspressoIO.get_recip_lattice","page":"Utilities","title":"QuantumEspressoIO.get_recip_lattice","text":"Compute reciprocal-space lattice vectors from real-space lattice vectors.\n\nArguments\n\nlattice: Can be a vector of lattice vectors, or a Mat3 matrix.\n\nExamples\n\nlattice = [[0.0, 1.0, 2.0], [3.0, 0.0, 4.0], [5.0, 6.0, 0.0]];\nget_recip_lattice(lattice)\n# output\n3-element Vector{Vector{Float64}}:\n [-2.6927937030769655, 2.243994752564138, 2.019595277307724]\n [1.3463968515384828, -1.121997376282069, 0.5609986881410345]\n [0.4487989505128276, 0.6731984257692414, -0.3365992128846207]\n\nlattice = mat3(lattice);\nget_recip_lattice(lattice)\n# output\n3×3 StaticArraysCore.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n -2.69279   1.3464     0.448799\n  2.24399  -1.122      0.673198\n  2.0196    0.560999  -0.336599\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#QuantumEspressoIO.format_fortran-Tuple{Any}","page":"Utilities","title":"QuantumEspressoIO.format_fortran","text":"Convert a Julia value to a string representation of Fortran value.\n\nExamples\n\njulia> format_fortran(\"hello\")\n\"'hello'\"\njulia> format_fortran(1.0)\n\"1.0\"\njulia> format_fortran(true)\n\".true.\"\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#QuantumEspressoIO.parse_bool-Tuple{AbstractString}","page":"Utilities","title":"QuantumEspressoIO.parse_bool","text":"parse_bool(s)\n\n\nParse a string as bool.\n\nThis is capable of parsing Fortran outputs, e.g., .true., .false., true, T.\n\nExamples\n\njulia> parse_bool(\".true.\")\ntrue\njulia> parse_bool(\"false\")\nfalse\njulia> parse_bool(\"T\")\ntrue\njulia> parse_bool(\"F\")\nfalse\njulia> parse_bool(\"1\")\ntrue\njulia> parse_bool(\"0\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#QuantumEspressoIO.parse_bool-Tuple{Integer}","page":"Utilities","title":"QuantumEspressoIO.parse_bool","text":"parse_bool(i)\n\n\nParse an integer as bool.\n\n0: false\n1 or -1: true\n\nExamples\n\njulia> parse_bool(1)\ntrue\njulia> parse_bool(0)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#QuantumEspressoIO.parse_float-Tuple{AbstractString}","page":"Utilities","title":"QuantumEspressoIO.parse_float","text":"parse_float(s)\n\n\nParse a string as Float64.\n\nThe is capable of parsing Fortran outputs, e.g. 1.0D-10, to the ordinary 1e-10.\n\nExamples\n\njulia> parse_float(\"1.0D-10\")\n1.0e-10\njulia> parse_float(\"1***\")\nNaN\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#QuantumEspressoIO.parse_value-Tuple{AbstractString}","page":"Utilities","title":"QuantumEspressoIO.parse_value","text":"parse_value(value)\n\n\nParse a Fortran value.\n\nExamples\n\njulia> parse_value(\"'hello'\")\n\"hello\"\njulia> parse_value(\".true.\")\ntrue\njulia> parse_value(\"1.0D-10\")\n1.0e-10\njulia> parse_value(\"1\")\n1\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#QuantumEspressoIO.remove_comment-Tuple{AbstractString}","page":"Utilities","title":"QuantumEspressoIO.remove_comment","text":"remove_comment(line)\n\n\nRemove comment and strip empty spaces.\n\nExamples\n\njulia> remove_comment(\"  ! This is a comment\")\n\"\"\njulia> remove_comment(\"  input\")\n\"input\"\njulia> remove_comment(\"  name1 = value1  ! comment 2\")\n\"name1 = value1\"\njulia> remove_comment(\"  name2 = value2  # comment 3\")\n\"name2 = value2\"\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#QuantumEspressoIO.FortranBinary","page":"Utilities","title":"QuantumEspressoIO.FortranBinary","text":"Fortran unformatted IO.\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#QuantumEspressoIO.FortranBinaryStream","page":"Utilities","title":"QuantumEspressoIO.FortranBinaryStream","text":"Fortran unformatted IO with stream access.\n\nFor example, file written using these Fortran code:\n\nOPEN(UNIT=11, FILE=\"ustream.demo\", STATUS=\"NEW\", ACCESS=\"STREAM\", FORM=\"UNFORMATTED\")\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#QuantumEspressoIO.FortranText","page":"Utilities","title":"QuantumEspressoIO.FortranText","text":"Fortran formatted IO.\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#QuantumEspressoIO.Mat3","page":"Utilities","title":"QuantumEspressoIO.Mat3","text":"3 x 3 matrix type.\n\nFor lattice and reciprocal lattice.\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#QuantumEspressoIO.SymbolVec3","page":"Utilities","title":"QuantumEspressoIO.SymbolVec3","text":"Pair type associating a Symbol with a Vec3.\n\nUsed for win file atoms_frac and kpoint_path.\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#QuantumEspressoIO.Vec3","page":"Utilities","title":"QuantumEspressoIO.Vec3","text":"Length-3 vector type.\n\nFor atom positions, kpoints, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#QuantumEspressoIO.mat3-Tuple{AbstractVector}","page":"Utilities","title":"QuantumEspressoIO.mat3","text":"mat3(A)\n\n\nConvert Vector{Vector} to Mat3. Each vector is a column of the matrix.\n\nnote: Note\nThis is not defined as a constructor of Mat3 to avoid type piracy.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#QuantumEspressoIO.vec3-Tuple{StaticArraysCore.SMatrix{3, 3, T, 9} where T}","page":"Utilities","title":"QuantumEspressoIO.vec3","text":"vec3(A)\n\n\nConvert Mat3 to Vec3{Vec3}. Each column of the matrix is a vector.\n\nnote: Note\nThis is not defined as a constructor of vec3 to avoid type piracy.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#QuantumEspressoIO.Bohr_QE","page":"Utilities","title":"QuantumEspressoIO.Bohr_QE","text":"Bohr radius in Angstrom unit.\n\nThis is the default (Physical constants, SI (NIST 2018)) value in QE Modules/constants.f90.\n\n\n\n\n\n","category":"constant"},{"location":"api/namelist/#Fortran-namelists","page":"Fortran Namelist","title":"Fortran namelists","text":"","category":"section"},{"location":"api/namelist/#Index","page":"Fortran Namelist","title":"Index","text":"Pages = [\n    \"namelist.md\",\n]","category":"section"},{"location":"api/namelist/#Documentation","page":"Fortran Namelist","title":"Documentation","text":"","category":"section"},{"location":"api/namelist/#QuantumEspressoIO.find_card-Tuple{AbstractVector, AbstractString}","page":"Fortran Namelist","title":"QuantumEspressoIO.find_card","text":"find_card(lines, name)\n\n\nFind a card in the lines. Ignore comments and empty lines.\n\nArguments\n\nlines::AbstractVector: The lines to read from.\nname::AbstractString: The name of the card to read.\n\nReturns\n\nThe index of the card in the lines. If not found, return nothing.\n\nExamples\n\nlines = [\n    \"  ! This is a comment\",\n    \"  input\",\n    \"  name1 = value1  ! comment 2\",\n    \"  name2 = value2\",\n]\nname = \"input\"\nfind_card(lines, name)\n# output\n2\n\n\n\n\n\n","category":"method"},{"location":"api/namelist/#QuantumEspressoIO.parse_card!","page":"Fortran Namelist","title":"QuantumEspressoIO.parse_card!","text":"parse_card!(lines, name)\nparse_card!(lines, name, n_lines)\n\n\nFrom lines, get the card with name name and n_lines following lines.\n\nArguments\n\nlines: The lines to read from.\nname: The name of the card to read.\nn_lines: The number of lines to read after the card name.   Comment lines are ignored and not counted as n_lines.   If nothing, read everything after the card.\n\nExample\n\nlines = [\n    \"  input option1\",\n    \"  ! This is a comment\",\n    \"  name1 = value1  ! comment 2\",\n    \"  name2 = value2\",\n]\nname = \"input\"\nn_lines = 1\ncard = parse_card!(lines, name, n_lines)\nprintln(card)\nprintln(lines)\n# output\n(\"option1\", [\"name1 = value1\"])\n[\"  name2 = value2\"]\n\n\n\n\n\n","category":"function"},{"location":"api/namelist/#QuantumEspressoIO.parse_card_option-Tuple{AbstractString}","page":"Fortran Namelist","title":"QuantumEspressoIO.parse_card_option","text":"parse_card_option(line)\n\n\nGet the option of a card.\n\nArguments\n\nline::AbstractString: The line of the card.\n\nReturns\n\nThe option of the card. If no option is found, return nothing.\n\nExamples\n\njulia> parse_card_option(\"POSITIONS angstrom  ! comment\")\n\"angstrom\"\n\n\n\n\n\n","category":"method"},{"location":"api/namelist/#QuantumEspressoIO.read_namelist-Tuple{Union{AbstractString, IO}, Union{AbstractString, Symbol}}","page":"Fortran Namelist","title":"QuantumEspressoIO.read_namelist","text":"read_namelist(io_or_filename, name; all_lines)\n\n\nRead a single Fortran namelist from a file or IO stream.\n\nArguments\n\nio_or_filename: The IO stream or filename to read from.\nname: The name of the namelist to read.\n\nKeyword Arguments\n\nall_lines: Return the remaining lines outside of the namelist. Default to false.\n\nReturns\n\nparams: The key-value pairs of the namelist.\nothers: Optional. A vector of strings, which are the remaining lines in the file.\n\nExamples\n\nio = IOBuffer(\"\"\"\n&input\n    a = 1\n    b = 2.0\n    c = 'test'\n    d = .true.\n/\nadditional line\n\"\"\")\nnamelist, others = read_namelist(io, \"input\"; all_lines=true)\n# output\n(OrderedCollections.OrderedDict{Symbol, Any}(:a => 1, :b => 2.0, :c => \"test\", :d => true), [\"additional line\"])\n\n\n\n\n\n","category":"method"},{"location":"api/namelist/#QuantumEspressoIO.read_namelists-Tuple{IO}","page":"Fortran Namelist","title":"QuantumEspressoIO.read_namelists","text":"read_namelists(io; all_lines)\n\n\nRead fortran namelists file.\n\nArguments\n\nio: The IO stream to read from.\n\nKeyword Arguments\n\nall_lines: Return the remaining lines outside of namelists. Default to false.\n\nReturns\n\nnamelists::OrderedDict: A dictionary of namelists, each key is a symbol and   the value is a OrderedDict of key-value pairs.\nothers::Vector: Optional. A vector of strings, which are the remaining lines in the file.   For example, QE pw.x input files may contain \"cards\" for additional parameters   (e.g. atomic positions, k-points, etc.), whose syntax are customarily defined   by pw.x.\n\nExamples\n\nio = IOBuffer(\"\"\"\n&input\n    a = 1\n    b = 2.0\n    c = 'test'\n    d = .true.\n/\nadditional line\n\"\"\")\nnamelists, others = read_namelists(io; all_lines=true)\n# output\n(OrderedCollections.OrderedDict{Symbol, Any}(:input => OrderedCollections.OrderedDict{Symbol, Any}(:a => 1, :b => 2.0, :c => \"test\", :d => true)), [\"additional line\"])\n\n\n\n\n\n","category":"method"},{"location":"api/namelist/#QuantumEspressoIO.write_namelist-Tuple{AbstractString, Union{AbstractString, Symbol}, AbstractDict}","page":"Fortran Namelist","title":"QuantumEspressoIO.write_namelist","text":"write_namelist(filename, name, params)\n\n\nWrite a Fortran namelist to a file.\n\nArguments\n\nfilename: The name of the file to write to.\nname: The name of the namelist.\nparams: The key-value pairs to write, which is a dictionary-like object.\n\n\n\n\n\n","category":"method"},{"location":"api/namelist/#QuantumEspressoIO.write_namelist-Tuple{IO, Union{AbstractString, Symbol}, AbstractDict}","page":"Fortran Namelist","title":"QuantumEspressoIO.write_namelist","text":"write_namelist(io, name, params)\n\n\nWrite a Fortran namelist.\n\nArguments\n\nio::IO: The IO stream to write to.\nname::StrOrSym: The name of the namelist.\nparams::AbstractDict: The key-value pairs to write, which is a dictionary-like object.\n\nExamples\n\nusing OrderedCollections\n\nname = :input\nparams = OrderedDict(\n    \"a\" => 1,\n    \"b\" => 2.0,\n    \"c\" => [3, 4, 5],\n    \"d\" => \"test\",\n    \"e\" => true,\n)\nwrite_namelist(stdout, name, params)\n# output\n&input\n  a = 1\n  b = 2.0\n  c(1) = 3\n  c(2) = 4\n  c(3) = 5\n  d = 'test'\n  e = .true.\n/\n\n\n\n\n\n","category":"method"},{"location":"api/namelist/#QuantumEspressoIO.write_namelists-Tuple{AbstractString, AbstractDict}","page":"Fortran Namelist","title":"QuantumEspressoIO.write_namelists","text":"write_namelists(filename, namelists)\n\n\nWrite multiple Fortran namelists to a file.\n\nArguments\n\nfilename::AbstractString: The name of the file to write to.\nnamelists::AbstractDict: The input parameters, see write_namelists(io::IO, namelists::AbstractDict) for details.\n\n\n\n\n\n","category":"method"},{"location":"api/namelist/#QuantumEspressoIO.write_namelists-Tuple{IO, AbstractDict}","page":"Fortran Namelist","title":"QuantumEspressoIO.write_namelists","text":"write_namelists(io, namelists)\n\n\nWrite multiple Fortran namelists to a file.\n\nArguments\n\nio: The IO stream to write to.\nnamelists: The namelists, each key-value pair is treated as a namelist.\n\nExamples\n\nusing OrderedCollections\n\n# Use OrderedDict to preserve the order of the keys\ninputs = OrderedDict(\n    :control => OrderedDict(\"calculation\" => \"scf\", \"prefix\" => \"qe\"),\n    :system => OrderedDict(\"ecutwfc\" => 30.0, \"ecutrho\" => 300.0),\n    :electrons => OrderedDict(\"mixing_beta\" => 0.7),\n)\nwrite_namelists(stdout, inputs)\n# output\n&control\n  calculation = 'scf'\n  prefix = 'qe'\n/\n&system\n  ecutwfc = 30.0\n  ecutrho = 300.0\n/\n&electrons\n  mixing_beta = 0.7\n/\n\n\n\n\n\n","category":"method"},{"location":"api/xml/#XML-files","page":"XML","title":"XML files","text":"","category":"section"},{"location":"api/xml/#Index","page":"XML","title":"Index","text":"Pages = [\n    \"xml.md\",\n]","category":"section"},{"location":"api/xml/#Documentation","page":"XML","title":"Documentation","text":"","category":"section"},{"location":"api/xml/#QuantumEspressoIO.read_pw_xml-Tuple{AbstractString}","page":"XML","title":"QuantumEspressoIO.read_pw_xml","text":"Read atomic structure and band structure from QE's XML output.\n\nReturn\n\nlattice: 3 * 3, Å, each column is a lattice vector\natom_positions: length-n_atoms vector, each element is a fractional position\natom_labels: length-n_atoms vector, each element is the label of the corresponding atom\nrecip_lattice: 3 * 3, Å⁻¹, each column is a reciprocal lattice vector\nkpoints: length-n_kpts vector, each element is a fractional kpoint\nfermi_energy: eV\nalat: the alat of QE in Å\neigenvalues: length-n_kpts vector, each element is a length-n_bands vector of   eigenvalue in eV. For spin-polarized but without SOC calculations,   return two arries of eigenvalues_up and eigenvalues_dn for the two spin channels.\n\n\n\n\n\n","category":"method"},{"location":"api/bin/#Fortran-binary-files","page":"Binaries","title":"Fortran binary files","text":"","category":"section"},{"location":"api/bin/#Index","page":"Binaries","title":"Index","text":"Pages = [\n    \"bin.md\",\n]","category":"section"},{"location":"api/bin/#Documentation","page":"Binaries","title":"Documentation","text":"","category":"section"},{"location":"api/bin/#QuantumEspressoIO.read_wfc_dat-Tuple{AbstractString}","page":"Binaries","title":"QuantumEspressoIO.read_wfc_dat","text":"Read wavefunction data from a QE's wfc.dat file.\n\nArguments\n\nfilename::AbstractString: The path to the wfc.dat file.\n\nReturn\n\nmiller: 3 * ngw, integer matrix of Miller indices for reciprocal lattice vectors.\nevc_list: Length-nbnd vector, each element is a length-igwx vector of   complex wavefunction coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/pw/#pw.x","page":"pw.x","title":"pw.x","text":"","category":"section"},{"location":"api/pw/#Index","page":"pw.x","title":"Index","text":"Pages = [\n    \"pw.md\",\n]","category":"section"},{"location":"api/pw/#Documentation","page":"pw.x","title":"Documentation","text":"","category":"section"},{"location":"api/pw/#QuantumEspressoIO.read_atomic_positions!-Tuple{AbstractVector, Integer}","page":"pw.x","title":"QuantumEspressoIO.read_atomic_positions!","text":"read_atomic_positions!(lines, n_atoms)\n\n\nParse the atomic_positions card of pw.x input.\n\nArguments\n\nlines::AbstractVector: The lines of the input file.\nn_atoms::Integer: The number of atoms in the atomic_positions card.\n\nReturns\n\nA Pair of card name to card content. The card option is stored under   the :option key in the card content.\n\nExamples\n\nlines = [\n    \"ATOMIC_POSITIONS crystal\",\n    \"! a comment line\",\n    \"Si        0.0000000000      0.0000000000      0.0000000000\",\n    \"O         0.5000000000      0.5000000000      0.5000000000\",\n    \"following line\",\n]\nn_atoms = 2\ncard = read_atomic_positions!(lines, n_atoms)\nprintln(card)\nprintln(lines)\n# output\n:atomic_positions => OrderedCollections.OrderedDict{Symbol, Any}(:option => \"crystal\", :atoms => [\"Si\", \"O\"], :positions => StaticArraysCore.SVector{3, Float64}[[0.0, 0.0, 0.0], [0.5, 0.5, 0.5]])\n[\"following line\"]\n\n\n\n\n\n","category":"method"},{"location":"api/pw/#QuantumEspressoIO.read_atomic_species!-Tuple{AbstractVector, Integer}","page":"pw.x","title":"QuantumEspressoIO.read_atomic_species!","text":"read_atomic_species!(lines, n_species)\n\n\nParse the atomic_species card of pw.x input.\n\nArguments\n\nlines::AbstractVector: The lines of the input file.\nn_species::Integer: The number of species in the atomic_species card.\n\nReturns\n\nA Pair of card name to card content. The card option is stored under   the :option key in the card content.\n\nExamples\n\nlines = [\n    \"ATOMIC_SPECIES\",\n    \"! a comment line\",\n    \"Si       28.085500  Si.upf\",\n    \"O        15.999000  O.upf\",\n    \"following line\",\n];\nn_species = 2;\ncard = read_atomic_species!(lines, n_species)\nprintln(card)\nprintln(lines)\n# output\n:atomic_species => OrderedCollections.OrderedDict{Symbol, Any}(:option => nothing, :species => [\"Si\", \"O\"], :masses => [28.0855, 15.999], :pseudos => [\"Si.upf\", \"O.upf\"])\n[\"following line\"]\n\n\n\n\n\n","category":"method"},{"location":"api/pw/#QuantumEspressoIO.read_cell_parameters!-Tuple{AbstractVector}","page":"pw.x","title":"QuantumEspressoIO.read_cell_parameters!","text":"read_cell_parameters!(lines)\n\n\nParse the cell_parameters card of pw.x input.\n\nArguments\n\nlines::AbstractVector: The lines of the input file.\n\nExamples\n\nlines = [\n    \"CELL_PARAMETERS angstrom\",\n    \"! a comment line\",\n    \"1.0 0.0 0.0\",\n    \"0.0 2.0 0.0\",\n    \"0.0 0.0 3.0\",\n    \"following line\",\n]\ncard = read_cell_parameters!(lines)\nprintln(card)\nprintln(lines)\n# output\n:cell_parameters => OrderedCollections.OrderedDict{Symbol, Any}(:option => \"angstrom\", :cell => StaticArraysCore.SVector{3, Float64}[[1.0, 0.0, 0.0], [0.0, 2.0, 0.0], [0.0, 0.0, 3.0]])\n[\"following line\"]\n\n\n\n\n\n","category":"method"},{"location":"api/pw/#QuantumEspressoIO.read_k_points!-Tuple{AbstractVector}","page":"pw.x","title":"QuantumEspressoIO.read_k_points!","text":"read_k_points!(lines)\n\n\nParse the k_points card of pw.x input.\n\nArguments\n\nlines::AbstractVector: The lines of the input file.\n\nReturns\n\nA Pair of card name to card content. The card option is stored under   the :option key in the card content.\n\nExamples\n\nlines = [\n    \"K_POINTS crystal\",\n    \"! a comment line\",\n    \"2\",\n    \"0.0 0.0 0.0 1.0\",\n    \"0.5 0.5 0.5 1.0\",\n    \"following line\",\n]\ncard = read_k_points!(lines)\nprintln(card)\nprintln(lines)\n# output\n:k_points => OrderedCollections.OrderedDict{Symbol, Any}(:option => \"crystal\", :kpoints => StaticArraysCore.SVector{3, Float64}[[0.0, 0.0, 0.0], [0.5, 0.5, 0.5]], :kweights => [1.0, 1.0])\n[\"following line\"]\n\n\n\n\n\n","category":"method"},{"location":"api/pw/#QuantumEspressoIO.read_pw_in-Tuple{Union{AbstractString, IO}}","page":"pw.x","title":"QuantumEspressoIO.read_pw_in","text":"read_pw_in(io)\n\n\nRead the pw.x input file.\n\nArguments\n\nio::Union{IO,AbstractString}: The IO stream or filename to read from.\n\nReturns\n\nA dictionary of namelists and cards. The keys are the names of the namelists or cards.\n\nExamples\n\nio = IOBuffer(\"\"\"\n    &control\n        calculation = \"scf\"\n    /\n    &system\n        ibrav = 0\n        nat = 2\n        ntyp = 2\n    /\n    ATOMIC_SPECIES\n    Si       28.085500  Si.upf\n    O        15.999000  O.upf\n    ATOMIC_POSITIONS crystal\n    Si        0.0000000000      0.0000000000      0.0000000000\n    O         0.5000000000      0.5000000000      0.5000000000\n    CELL_PARAMETERS angstrom\n    1.0 0.0 0.0\n    0.0 2.0 0.0\n    0.0 0.0 3.0\n    K_POINTS crystal\n    2\n    0.0000000000      0.0000000000      0.0000000000      1.0000000000\n    0.5000000000      0.5000000000      0.5000000000      1.0000000000\n\"\"\")\ninputs = read_pw_in(io)\nprintln(inputs)\n# output\nOrderedCollections.OrderedDict{Symbol, Any}(:control => OrderedCollections.OrderedDict{Symbol, Any}(:calculation => \"scf\"), :system => OrderedCollections.OrderedDict{Symbol, Any}(:ibrav => 0, :nat => 2, :ntyp => 2), :atomic_species => OrderedCollections.OrderedDict{Symbol, Any}(:option => nothing, :species => [\"Si\", \"O\"], :masses => [28.0855, 15.999], :pseudos => [\"Si.upf\", \"O.upf\"]), :atomic_positions => OrderedCollections.OrderedDict{Symbol, Any}(:option => \"crystal\", :atoms => [\"Si\", \"O\"], :positions => StaticArraysCore.SVector{3, Float64}[[0.0, 0.0, 0.0], [0.5, 0.5, 0.5]]), :cell_parameters => OrderedCollections.OrderedDict{Symbol, Any}(:option => \"angstrom\", :cell => StaticArraysCore.SVector{3, Float64}[[1.0, 0.0, 0.0], [0.0, 2.0, 0.0], [0.0, 0.0, 3.0]]), :k_points => OrderedCollections.OrderedDict{Symbol, Any}(:option => \"crystal\", :kpoints => StaticArraysCore.SVector{3, Float64}[[0.0, 0.0, 0.0], [0.5, 0.5, 0.5]], :kweights => [1.0, 1.0]))\n\n\n\n\n\n","category":"method"},{"location":"api/pw/#QuantumEspressoIO.write_atomic_positions-Tuple{IO, AbstractDict}","page":"pw.x","title":"QuantumEspressoIO.write_atomic_positions","text":"write_atomic_positions(io, card)\n\n\nWrite the atomic_positions card of pw.x.\n\nExamples\n\ninputs = Dict(\n    :option => \"crystal\",\n    :atoms => [\"Si\", \"O\"],\n    :positions => [\n        [0.0, 0.0, 0.0],\n        [0.5, 0.5, 0.5],\n    ],\n)\nwrite_atomic_positions(stdout, inputs)\n# output\nATOMIC_POSITIONS crystal\nSi        0.0000000000      0.0000000000      0.0000000000\nO         0.5000000000      0.5000000000      0.5000000000\n\n\n\n\n\n","category":"method"},{"location":"api/pw/#QuantumEspressoIO.write_atomic_species-Tuple{IO, AbstractDict}","page":"pw.x","title":"QuantumEspressoIO.write_atomic_species","text":"write_atomic_species(io, card)\n\n\nWrite the atomic_species card of pw.x.\n\nExamples\n\ninputs = Dict(\n    :species => [\"Si\", \"O\"],\n    :masses => [28.0855, 15.999],\n    :pseudos => [\"Si.upf\", \"O.upf\"],\n)\nwrite_atomic_species(stdout, inputs)\n# output\nATOMIC_SPECIES\nSi       28.085500  Si.upf\nO        15.999000  O.upf\n\n\n\n\n\n","category":"method"},{"location":"api/pw/#QuantumEspressoIO.write_cell_parameters-Tuple{IO, AbstractDict}","page":"pw.x","title":"QuantumEspressoIO.write_cell_parameters","text":"write_cell_parameters(io, card)\n\n\nWrite the cell_parameters card of pw.x.\n\nExamples\n\ninputs = Dict(\n    :option => \"angstrom\",\n    :cell => [\n        [1.0, 0.0, 0.0],\n        [0.0, 2.0, 0.0],\n        [0.0, 0.0, 3.0],\n    ],\n)\nwrite_cell_parameters(stdout, inputs)\n# output\nCELL_PARAMETERS angstrom\n    1.0000000000      0.0000000000      0.0000000000\n    0.0000000000      2.0000000000      0.0000000000\n    0.0000000000      0.0000000000      3.0000000000\n\n\n\n\n\n","category":"method"},{"location":"api/pw/#QuantumEspressoIO.write_k_points-Tuple{IO, AbstractDict}","page":"pw.x","title":"QuantumEspressoIO.write_k_points","text":"write_k_points(io, card)\n\n\nWrite the k_points card of pw.x.\n\nExamples\n\ninputs = Dict(\n    :option => \"crystal\",\n    :kpoints => [\n        [0.0, 0.0, 0.0],\n        [0.5, 0.5, 0.5],\n    ],\n    :kweights => [1.0, 1.0],\n)\nwrite_k_points(stdout, inputs)\n# output\nK_POINTS crystal\n2\n    0.0000000000      0.0000000000      0.0000000000      1.0000000000\n    0.5000000000      0.5000000000      0.5000000000      1.0000000000\n\ninputs = Dict(\n    :option => \"automatic\",\n    :kgrid => [8, 8, 8],\n    :kgrid_shift => [0, 1, 1],\n)\nwrite_k_points(stdout, inputs)\n# output\nK_POINTS automatic\n8 8 8    0 1 1\n\n\n\n\n\n","category":"method"},{"location":"api/pw/#QuantumEspressoIO.write_pw_in-Tuple{AbstractString, AbstractDict}","page":"pw.x","title":"QuantumEspressoIO.write_pw_in","text":"write_pw_in(filename, inputs)\n\n\nWrite the pw.x input file to a file.\n\nArguments\n\nfilename::AbstractString: The name of the file to write to.\ninputs::AbstractDict: See write_pw_in(io::IO, inputs::AbstractDict) for details.\n\n\n\n\n\n","category":"method"},{"location":"api/pw/#QuantumEspressoIO.write_pw_in-Tuple{IO, AbstractDict}","page":"pw.x","title":"QuantumEspressoIO.write_pw_in","text":"write_pw_in(io, inputs)\n\n\nWrite the pw.x input file.\n\nArguments\n\nio::IO: The IO stream to write to.\ninputs::AbstractDict: The input data:\nThe keys are the names of the namelists or cards.\nThe values are the corresponding data for the namelists or cards.\nThe namelists are written first, followed by the cards.\n\nExamples\n\n# Use OrderedDict to preserve the order of the keys\nusing OrderedCollections\n\ninputs = OrderedDict(\n    :control => OrderedDict(\n        :calculation => \"scf\",\n        :prefix => \"SiO\",\n        :outdir => \"./out\",\n        :pseudo_dir => \"./pseudo\",\n    ),\n    :system => OrderedDict(\n        :ibrav => 0,\n        :nat => 2,\n        :ntyp => 2,\n    ),\n    :electrons => OrderedDict(\n        :conv_thr => 1e-6,\n    ),\n    :atomic_species => Dict(\n        :species => [\"Si\", \"O\"],\n        :masses => [28.0855, 15.999],\n        :pseudos => [\"Si.upf\", \"O.upf\"],\n    ),\n    :atomic_positions => Dict(\n        :option => \"crystal\",\n        :atoms => [\"Si\", \"O\"],\n        :positions => [\n            [0.0, 0.0, 0.0],\n            [0.5, 0.5, 0.5],\n        ],\n    ),\n    :cell_parameters => Dict(\n        :option => \"angstrom\",\n        :cell => [\n            [1.0, 0.0, 0.0],\n            [0.0, 2.0, 0.0],\n            [0.0, 0.0, 3.0],\n        ],\n    ),\n    :k_points => Dict(\n        :option => \"crystal\",\n        :kpoints => [\n            [0.0, 0.0, 0.0],\n            [0.5, 0.5, 0.5],\n        ],\n        :kweights => [1.0, 1.0],\n    ),\n)\nwrite_pw_in(stdout, inputs)\n# output\n&control\n  calculation = 'scf'\n  prefix = 'SiO'\n  outdir = './out'\n  pseudo_dir = './pseudo'\n/\n&system\n  ibrav = 0\n  nat = 2\n  ntyp = 2\n/\n&electrons\n  conv_thr = 1.0e-6\n/\nATOMIC_SPECIES\nSi       28.085500  Si.upf\nO        15.999000  O.upf\nATOMIC_POSITIONS crystal\nSi        0.0000000000      0.0000000000      0.0000000000\nO         0.5000000000      0.5000000000      0.5000000000\nCELL_PARAMETERS angstrom\n    1.0000000000      0.0000000000      0.0000000000\n    0.0000000000      2.0000000000      0.0000000000\n    0.0000000000      0.0000000000      3.0000000000\nK_POINTS crystal\n2\n    0.0000000000      0.0000000000      0.0000000000      1.0000000000\n    0.5000000000      0.5000000000      0.5000000000      1.0000000000\n\n\n\n\n\n","category":"method"},{"location":"#QuantumEspressoIO","page":"Home","title":"QuantumEspressoIO","text":"Documentation for QuantumEspressoIO.","category":"section"}]
}
