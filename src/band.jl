using LinearAlgebra

"""
    $(SIGNATURES)

Read QE `bands.x` or `matdyn.x` output data file.

The band data file is generated by `bands.x` with the following parameters:
```
&BANDS
    filband = 'band.out'
/
```

The data file has format
```
 &plot nbnd=  20, nks=   380 /
           -0.500000  0.500000  0.500000
   -3.320   -0.666    5.173    5.173    7.994    9.725    9.725   14.147   16.993   16.993
   17.841   17.841   17.902   19.666   25.961   26.563   28.186   28.186   28.368   28.368
           -0.495000  0.495000  0.495000
   -3.322   -0.664    5.173    5.173    7.994    9.725    9.725   14.148   16.980   16.980
...
```

Or the phonon frequencies data file generated by `matdyn.x` with the following parameters:
```
&input
  flfrc = 'q2r.fc'
  flfrq = 'matdyn.freq'
/
...
```

The data file has format
```
 &plot nbnd=  18, nks= 215 /
            0.000000  0.000000  0.000000  0.000000
   -3.0736   -2.4224    0.0000   69.1415   89.0045  111.0355
  129.0629  132.0871  133.5105  140.4330  142.5639  167.4426
  180.4574  181.5249  183.9153  216.1158  223.2463  243.1283
            0.000000  0.026425  0.000000  0.000000
  -11.3695    4.9224    8.1107   67.6370   88.6929  111.2569
  129.0904  132.0795  132.3089  140.0579  140.6348  167.3281
  179.8108  181.5110  183.1559  216.1344  222.9383  243.2523
...
```

# Returns
- `kpoints`: Vector of k/q points in Cartesian coordinates, but scaled by QE `alat`
- `eigenvalues`: Vector of eigenvalues for each kpoint

# Examples
```jldoctest; setup = (using QuantumEspressoIO: read_band_dat)
io = IOBuffer(\"""&plot nbnd=  2, nks=  11 /
0.0  0.0  0.0
-1.0  0.0  1.0  2.0  3.0  4.0  5.0  6.0  7.0  8.0
9.0
\""")
kpoints, eigenvalues = read_band_dat("band.out")
println(kpoints)
println(eigenvalues)
# output
[[0.0, 0.0, 0.0]]
[[-1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]]
"""
function read_band_dat(io::IO)
    line = readline(io)
    regex = r"&plot nbnd=\s*(\d+), nks=\s*(\d+) /"
    m = match(regex, line)
    alat = nothing
    if isnothing(m)
        # this is my customized version, with `alat` added to header,
        # so we can return kpoints in Å⁻¹ unit instead of arbitrary
        regex = r"&plot nbnd=\s*(\d+), nks=\s*(\d+) alat=\s*([+-]?([0-9]*[.])?[0-9]+) /"
        m = match(regex, line)
        n_bands, n_kpts = parse.(Int, m.captures[1:2])
        alat = parse.(Float64, m.captures[3])
    else
        n_bands, n_kpts = parse.(Int, m.captures)
    end

    kpoints = Vec3{Float64}[]
    kweights = Float64[]
    eigenvalues = Vector{Float64}[]

    for _ in 1:n_kpts
        # QE kpt are in cartesian coordinates, but scaled by `alat`
        kpt = parse.(Float64, split(readline(io)))
        push!(kpoints, kpt[1:3])
        if length(kpt) >= 4
            push!(kweights, kpt[4])
        end
        ib = 1
        eig = zeros(Float64, n_bands)
        while ib <= n_bands
            e = parse.(Float64, split(readline(io)))
            n_e = length(e)
            eig[ib:(ib + n_e - 1)] = e
            ib += n_e
        end
        (ib == (n_bands + 1)) || error("Number of eigenvalues != number of bands")
        push!(eigenvalues, eig)
    end

    if isempty(kweights)
        return (; kpoints, eigenvalues)
    else
        return (; kpoints, eigenvalues, kweights)
    end
end

function read_band_dat(filename::AbstractString)
    return open(filename) do io
        read_band_dat(io)
    end
end

"""
    $(SIGNATURES)

Guess high symmetry points from kpoint coordinates.

If there is angle between two consecutive kpoints, then
it is identified as a high-symmetry kpoint.

# Arguments
- `kpoints`: kpoints in Cartesian coordinates

# Keyword Arguments
- `atol`: Absolute tolerance for checking cross product of two vectors

# Returns
- Vector of indices of high-symmetry points

# Examples
```jldoctest; setup = (using QuantumEspressoIO: guess_high_symmetry_kpoints)
kpoints = [
    [0.0, 0.0, 0.0],
    [0.1, 0.0, 0.0],
    [0.1, 0.1, 0.0],
    [0.1, 0.1, 0.1],
]
guess_high_symmetry_kpoints(kpoints)
# output
[1, 3, 4]
"""
function guess_high_symmetry_kpoints(kpoints::AbstractVector; atol::AbstractFloat=2e-6)
    symm_point_indices = Int[]

    n_kpts = length(kpoints)
    if n_kpts == 0
        return symm_point_indices
    end

    # push the first kpt
    push!(symm_point_indices, 1)

    for ik in 2:(n_kpts - 1)
        u = kpoints[ik] - kpoints[ik - 1]
        v = kpoints[ik + 1] - kpoints[ik]
        # We need the angle between the two vectors, thus requiring them to be
        # in Cartesian coordinates.
        if !all(isapprox.(cross(u, v), 0; atol))
            push!(symm_point_indices, ik)
        end
    end

    # Add the last kpt
    push!(symm_point_indices, n_kpts)

    return symm_point_indices
end
