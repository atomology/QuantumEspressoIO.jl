using Printf
using OrderedCollections

export read_namelist, read_namelists, write_namelist, write_namelists

"""
    $(SIGNATURES)

Read fortran namelists file.

# Arguments
- `io`: The IO stream to read from.

# Keyword Arguments
- `all_lines`: Return the remaining lines outside of namelists. Default to `false`.

# Returns
- `namelists::OrderedDict`: A dictionary of namelists, each key is a symbol and
    the value is a `OrderedDict` of key-value pairs.
- `others::Vector`: Optional. A vector of strings, which are the remaining lines in the file.
    For example, QE `pw.x` input files may contain "cards" for additional parameters
    (e.g. atomic positions, k-points, etc.), whose syntax are customarily defined
    by `pw.x`.

# Examples
```jldoctest; setup = :(using QuantumEspressoIO: read_namelists)
io = IOBuffer(\"""
&input
    a = 1
    b = 2.0
    c = 'test'
    d = .true.
/
additional line
\""")
namelists, others = read_namelists(io; all_lines=true)
# output
(OrderedCollections.OrderedDict{Symbol, Any}(:input => OrderedCollections.OrderedDict{Symbol, Any}(:a => 1, :b => 2.0, :c => "test", :d => true)), ["additional line"])
```
"""
function read_namelists(io::IO; all_lines::Bool=false)
    namelists = OrderedDict{Symbol,Any}()
    others = String[]

    current_namelist = nothing

    for rawline in eachline(io)
        @debug "[read_namelists] $rawline"
        line = strip(rawline)
        # note this also remove inline comment
        line = remove_comment(line)
        isempty(line) && continue

        if startswith(line, "&")
            # Parse namelist
            # fortran is case-insensitive, so we convert to lowercase
            name = Symbol(lowercase(line[2:end]))
            namelists[name] = OrderedDict{Symbol,Any}()
            current_namelist = name
        elseif startswith(line, "/")
            # End of namelist
            current_namelist = nothing
            if length(line) > 1
                @warn "Content after / is ignored: $line"
            end
        elseif current_namelist !== nothing
            # Parse key-value pairs
            key_value_pairs = split(line, "="; limit=2)
            # fortran is case-insensitive, so we convert to lowercase
            key = Symbol(lowercase(strip(key_value_pairs[1])))
            # to be safe, we still keep the case of value unchanged
            value = strip(key_value_pairs[2])
            namelists[current_namelist][key] = parse_value(value)
        else
            # Remaining lines, keep raw lines
            push!(others, rawline)
        end
    end

    if all_lines
        return namelists, others
    else
        if !isempty(others)
            @warn "$(length(others)) remaining lines are ignored: $(others[1])\n...\n$(others[end])"
        end
        return namelists
    end
end

function read_namelists(filename::AbstractString; kwargs...)
    return open(filename) do io
        read_namelists(io; kwargs...)
    end
end

"""
    $(SIGNATURES)

Read a single Fortran namelist from a file or IO stream.

# Arguments
- `io_or_filename`: The IO stream or filename to read from.
- `name`: The name of the namelist to read.

# Keyword Arguments
- `all_lines`: Return the remaining lines outside of the namelist. Default to `false`.

# Returns
- `params`: The key-value pairs of the namelist.
- `others`: Optional. A vector of strings, which are the remaining lines in the file.

# Examples
```jldoctest; setup = :(using QuantumEspressoIO: read_namelist)
io = IOBuffer(\"""
&input
    a = 1
    b = 2.0
    c = 'test'
    d = .true.
/
additional line
\""")
namelist, others = read_namelist(io, "input"; all_lines=true)
# output
(OrderedCollections.OrderedDict{Symbol, Any}(:a => 1, :b => 2.0, :c => "test", :d => true), ["additional line"])
```
"""
function read_namelist(
    io_or_filename::Union{IO,AbstractString}, name::StrOrSym; all_lines::Bool=false
)
    if all_lines
        namelists, others = read_namelists(io_or_filename; all_lines)
    else
        namelists = read_namelists(io_or_filename; all_lines)
    end
    params = get(namelists, Symbol(name), nothing)
    isnothing(params) && error("Namelist $name not found")
    if all_lines
        return params, others
    else
        return params
    end
end

"""
    $(SIGNATURES)

Find a card in the lines. Ignore comments and empty lines.

# Arguments
- `lines::AbstractVector`: The lines to read from.
- `name::AbstractString`: The name of the card to read.

# Returns
- The index of the card in the lines. If not found, return `nothing`.

# Examples
```jldoctest; setup = :(using QuantumEspressoIO: find_card)
lines = [
    "  ! This is a comment",
    "  input",
    "  name1 = value1  ! comment 2",
    "  name2 = value2",
]
name = "input"
find_card(lines, name)
# output
2
```
"""
function find_card(lines::AbstractVector, name::AbstractString)
    lname = lowercase(name)
    return findfirst(line -> startswith(lowercase(remove_comment(line)), lname), lines)
end

# TODO only considers pw keywords for now
function is_namelist_keyword(line; keywords=PW_KEYWORDS)
    line = strip(line)
    startswith(line, "&") && return true

    sl = split(line)[1]
    lowercase(sl) in keywords && return true
    return false
end

"""
    $(SIGNATURES)

Find the last non-empty line in the card, which is determined by:
1. end of file
2. next card keywords
3. empty line

# Arguments
- `lines::AbstractVector`: The lines to read from.
- `icard::Integer`: Beginning of the current card.

# Returns
- The index of the last line in the card.

# Examples
```jldoctest; setup = :(using QuantumEspressoIO: end_of_card)
lines = [
    "HUBBARD atomic",
    "U Ni-3d 5.77",
    "U Ni1-3d 5.77",
    "ATOMIC_POSITIONS"
]

end_of_card(lines, 1)
# output
3
"""
function end_of_card(lines::AbstractVector, istart::Integer)
    # advance to next line
    istart += 1
    while istart <= length(lines)
        line = strip(lines[istart])
        isempty(line) && return istart - 1
        is_namelist_keyword(line) && return istart - 1
        istart += 1
    end
    # end of lines
    return istart - 1
end

"""
    $(SIGNATURES)

Count how many valid lines from istart to iend in lines inclusive.

# Examples
```jldoctest; setup = :(using QuantumEspressoIO: num_valid_lines)
lines = [
    "HUBBARD atomic",
    "! a comment line",
    "! another comment line",
    "U Ni-3d 5.77",
    "U Ni1-3d 5.77",
    "V Ni-3d O-2p 1 12 3.5",
    "",
]
nlines = num_valid_lines(lines, 1, 7)
println(nlines)
# output
4
"""
function num_valid_lines(lines::AbstractVector, istart::Integer, iend::Integer)
    i = istart
    num_lines = iend - istart + 1
    while i <= iend
        line = remove_comment(lines[i])
        if isempty(line)
            num_lines -= 1
        end
        i += 1
    end
    return num_lines
end

"""
    $(SIGNATURES)

Get the option of a card.

# Arguments
- `line::AbstractString`: The line of the card.

# Returns
- The option of the card. If no option is found, return `nothing`.

# Examples
```jldoctest; setup = :(using QuantumEspressoIO: parse_card_option)
julia> parse_card_option("POSITIONS angstrom  ! comment")
"angstrom"
```
"""
@inline function parse_card_option(line::AbstractString)
    cardline = remove_comment(line)
    parts = split(cardline; limit=2)
    option = length(parts) < 2 ? nothing : parts[2]
    return option
end

"""
    $(SIGNATURES)

From lines, get the card with name `name` and `n_lines` following lines.

# Arguments
- `lines`: The lines to read from.
- `name`: The name of the card to read.
- `n_lines`: The number of lines to read after the card name.
    Comment lines are ignored and not counted as `n_lines`.
    If `nothing`, read everything after the card.

# Example
```jldoctest; setup = :(using QuantumEspressoIO: parse_card!)
lines = [
    "  input option1",
    "  ! This is a comment",
    "  name1 = value1  ! comment 2",
    "  name2 = value2",
]
name = "input"
n_lines = 1
card = parse_card!(lines, name, n_lines)
println(card)
println(lines)
# output
("option1", ["name1 = value1"])
["  name2 = value2"]
```
"""
function parse_card!(
    lines::AbstractVector, name::AbstractString, n_lines::Union{Integer,Nothing}=nothing
)
    istart = find_card(lines, name)
    # nothing found
    isnothing(istart) && return nothing

    option = parse_card_option(lines[istart])

    # remove any comments in the card
    content = String[]
    i = istart
    while length(content) < n_lines
        i += 1
        if i > length(lines)
            error("Not enough lines in the card")
        end
        line = remove_comment(lines[i])
        isempty(line) && continue
        push!(content, line)
    end
    iend = i

    deleteat!(lines, istart:iend)

    return option, content
end

"""
    $(SIGNATURES)

Write a Fortran namelist.

# Arguments
- `io::IO`: The IO stream to write to.
- `name::StrOrSym`: The name of the namelist.
- `params::AbstractDict`: The key-value pairs to write, which is a dictionary-like object.

# Examples
```jldoctest; setup = :(using QuantumEspressoIO: write_namelist)
using OrderedCollections

name = :input
params = OrderedDict(
    "a" => 1,
    "b" => 2.0,
    "c" => [3, 4, 5],
    "d" => "test",
    "e" => true,
)
write_namelist(stdout, name, params)
# output
&input
  a = 1
  b = 2.0
  c(1) = 3
  c(2) = 4
  c(3) = 5
  d = 'test'
  e = .true.
/
```
"""
function write_namelist(io::IO, name::StrOrSym, params::AbstractDict)
    println(io, "&" * string(name))
    indent = 2
    for (k, v) in params
        # convert to fortran values
        if isnothing(v)
            continue
        elseif isa(v, AbstractVector)
            for (i, vi) in enumerate(v)
                fvi = format_fortran(vi)
                @printf(io, "%s%s(%d) = %s\n", ' '^indent, k, i, fvi)
            end
        else
            fv = format_fortran(v)
            @printf(io, "%s%s = %s\n", ' '^indent, k, fv)
        end
    end
    return println(io, "/")
end

"""
    $(SIGNATURES)

Write a Fortran namelist to a file.

# Arguments
- `filename`: The name of the file to write to.
- `name`: The name of the namelist.
- `params`: The key-value pairs to write, which is a dictionary-like object.
"""
function write_namelist(filename::AbstractString, name::StrOrSym, params::AbstractDict)
    return open(filename, "w") do io
        write_namelist(io, name, params)
    end
end

function write_namelist(io::Union{IO,AbstractString}, namelist::Pair)
    name = first(namelist)
    params = second(namelist)
    return write_namelist(io, name, params)
end

"""
    $(SIGNATURES)

Write multiple Fortran namelists to a file.

# Arguments
- `io`: The IO stream to write to.
- `namelists`: The namelists, each key-value pair is treated as a namelist.

# Examples
```jldoctest
using OrderedCollections

# Use OrderedDict to preserve the order of the keys
inputs = OrderedDict(
    :control => OrderedDict("calculation" => "scf", "prefix" => "qe"),
    :system => OrderedDict("ecutwfc" => 30.0, "ecutrho" => 300.0),
    :electrons => OrderedDict("mixing_beta" => 0.7),
)
write_namelists(stdout, inputs)
# output
&control
  calculation = 'scf'
  prefix = 'qe'
/
&system
  ecutwfc = 30.0
  ecutrho = 300.0
/
&electrons
  mixing_beta = 0.7
/
```
"""
function write_namelists(io::IO, namelists::AbstractDict)
    for (name, nml) in pairs(namelists)
        write_namelist(io, name, nml)
    end
end

"""
    $(SIGNATURES)

Write multiple Fortran namelists to a file.

# Arguments
- `filename::AbstractString`: The name of the file to write to.
- `namelists::AbstractDict`: The input parameters, see [`write_namelists(io::IO, namelists::AbstractDict)`](@ref) for details.
"""
function write_namelists(filename::AbstractString, namelists::AbstractDict)
    return open(filename, "w") do io
        write_namelists(io, namelists)
    end
end
